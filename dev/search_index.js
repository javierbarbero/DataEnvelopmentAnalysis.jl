var documenterSearchIndex = {"docs":
[{"location":"statistical/rtstest/#Returns-to-Scale-(RTS)-Test","page":"Returns to Scale Test","title":"Returns to Scale (RTS) Test","text":"The non-parametric Returns to Scale test (Simar and Wilson, 2002) is based on the bootstrap radial DEA model. It tests the hypothesis that the technology exhibits constant returns to scale (CRS) against the alternative that it is variable returns to scale (VRS):\n\nbeginaligned\n  H_0  text Technology is CRS \n  H_1  text Tecnhology is VRS\nendaligned\n\nThe test can be performed with the deartstest function, indicating the number of bootstrap replications in the nreps parameter. A random number generator can be specified in the rng parameter for reproducibility.\n\nusing DataEnvelopmentAnalysis\nusing StableRNGs\n\nX = [2, 4, 3, 5, 6]\nY = [1, 2, 3, 4, 5]\n\nioboot = deartstest(X, Y, orient = :Input, nreps = 200, rng = StableRNG(1234567))\n\nwarning: Number of bootstrap replications\nThe example above uses 200 bootstrap replications for illustrative purposes. In practice, at least 1000 replications are recommended.\n\nWe reject the null hypothesis if the estimated scale efficiency is less than the critical value. Alternatively, we can guide our decision using the calculated p-value. In the example above, we do not reject the null hypothesis of constant returns to scale.","category":"section"},{"location":"statistical/rtstest/#deaboot-Function-Documentation","page":"Returns to Scale Test","title":"deaboot Function Documentation","text":"","category":"section"},{"location":"statistical/rtstest/#DataEnvelopmentAnalysis.deartstest","page":"Returns to Scale Test","title":"DataEnvelopmentAnalysis.deartstest","text":"deartstest(X, Y)\n\nCompute the DEA Returns to Scale (RTS) test using the bootstrap radial model for inputs X and outputs Y.\n\nOptional Arguments\n\nnreps=200: number of bootstrap replications.\nrng=default_rng(): random number generator.\norient=:Input: chooses the radially oriented input mode. For the radially oriented output model choose :Output.\n\n\n\n\n\n","category":"function"},{"location":"statistical/rtstest/#DataEnvelopmentAnalysis.criticalvalue-Tuple{DEAReturnsToScaleTest}","page":"Returns to Scale Test","title":"DataEnvelopmentAnalysis.criticalvalue","text":"criticalvalue(model::BootstrapRadialDEAModel, alpha = 0.05)\n\nReturn the critical value of the DEA Returns to Scale Test, with level alpha.\n\n\n\n\n\n","category":"method"},{"location":"technical/russell/#Russell-Models","page":"Russell Models","title":"Russell Models","text":"","category":"section"},{"location":"technical/russell/#Russell-Input-Model","page":"Russell Models","title":"Russell Input Model","text":"Based on the data  matrix (XY), we calculate the Russell measure of input efficiency (Färe & Lovell, 1978; and Färe et al., 1985) of each observation o by solving n times the following linear programming problem:\n\nbeginaligned\n   undersettheta_i lambda_j mathopmin quad quad quad  frac1m sum_i=1^mtheta_i  \n   textsubject textto  \n   quad quad quad quad quad  sum_j=1^nlambda_j x_ij  le theta_i x_io qquad i = 1m  \n   quad quad quad quad quad  sum_j=1^nlambda_j y_rj  ge y_ro qquad r = 1s \n   quad quad quad quad quad  theta_i le 1 qquad i = 1m  \n   quad quad quad quad quad  lambda_j ge 0 qquad j = 1n \nendaligned\n\nThe measurement of technical efficiency assuming variable returns to scale, VRS, adds the following condition:\n\nsumnolimits_j=1^nlambda_j=1\n\nIn this example we compute the Russell input DEA model under constant returns to scale:\n\nusing DataEnvelopmentAnalysis\n\nX = [2 2; 1 4; 4 1; 4 3; 5 5; 6 1; 2 5; 1.6 8];\n\nY = [1; 1; 1; 1; 1; 1; 1; 1];\n\ndearussellio = dearussell(X, Y, orient = :Input, rts = :CRS)\n\nTo compute the variable returns to scale model, we simply set the rts parameter to :VRS:\n\nEstimated efficiency scores are returned with the efficiency function:\n\nefficiency(dearussellio)\n\nefficiency(dearussellio, :X)","category":"section"},{"location":"technical/russell/#Russell-Output-Model","page":"Russell Models","title":"Russell Output Model","text":"It is possible to calculate the Russell measure of output efficiency of each observation by solving the following linear program:\n\nbeginaligned\n   undersetphi_r lambda_j mathopmax quad quad quad  frac1s sum_r=1^sphi_r  \n   textsubject textto  \n   quad quad quad quad quad  sum_j=1^nlambda_j x_ij  le x_io qquad i = 1m  \n   quad quad quad quad quad  sum_j=1^nlambda_j y_rj  ge phi_r y_ro qquad r = 1s \n   quad quad quad quad quad  phi_r ge 1 qquad r = 1s \n   quad quad quad quad quad  lambda_j ge 0 qquad j = 1n \nendaligned\n\nwith the following condition when assuming variable returns to scale:\n\nsumnolimits_j=1^nlambda_j=1\n\nIn this example we compute the Russell output DEA model under constant returns to scale:\n\nX = [1; 1; 1; 1; 1; 1; 1; 1];\n\nY = [7 7; 4 8; 8 4; 3 5; 3 3; 8 2; 6 4; 1.5 5] ;\n\ndearusselloo = dearussell(X, Y, orient = :Output, rts = :CRS)\n\nEstimated efficiency scores are returned with the efficiency function:\n\nefficiency(dearusselloo)\n\nefficiency(dearusselloo, :Y)","category":"section"},{"location":"technical/russell/#Russell-Graph-Model","page":"Russell Models","title":"Russell Graph Model","text":"It is possible to calculate the Russell graph measure of technical efficiency of each observation by solving the following linear program:\n\nbeginaligned\n   undersettheta_i phi_r lambda_j mathopmin quad quad quad  frac1m + s (sum_i=1^mtheta_i +  sum_r=1^sfrac1phi_r)  \n   textsubject textto  \n   quad quad quad quad quad  sum_j=1^nlambda_j x_ij  le theta_i x_io  qquad i = 1m  \n   quad quad quad quad quad  sum_j=1^nlambda_j y_rj  ge phi_r y_ro qquad r = 1s \n   quad quad quad quad quad  theta_i le 1 qquad i = 1m  \n   quad quad quad quad quad  phi_r ge 1 qquad r = 1s \n   quad quad quad quad quad  lambda_j ge 0 qquad j = 1n \nendaligned\n\nwith the following condition when assuming variable returns to scale:\n\nsumnolimits_j=1^nlambda_j=1\n\nIn this example we compute the Russell graph DEA model under variable returns to scale:\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\ndearussellgr = dearussell(X, Y, orient = :Graph, rts = :VRS)\n\nEstimated efficiency scores are returned with the efficiency function:\n\nefficiency(dearussellgr)\n\nefficiency(dearussellgr, :X)\n\nefficiency(dearussellgr, :Y)","category":"section"},{"location":"technical/russell/#dearussell-Function-Documentation","page":"Russell Models","title":"dearussell Function Documentation","text":"","category":"section"},{"location":"technical/russell/#DataEnvelopmentAnalysis.dearussell","page":"Russell Models","title":"DataEnvelopmentAnalysis.dearussell","text":"dearussell(X, Y)\n\nCompute the Russell model using data envelopment analysis for inputs X and outputs Y.\n\nOptional Arguments\n\norient=:Input: chooses the Russell input mode. For the Russell output model choose :Output. For the Russell graph model choose :Graph.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nslack=true: computes input and output slacks.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"statistical/radialboot/#Bootstrap-Radial-Model","page":"Bootstrap Radial DEA Model","title":"Bootstrap Radial Model","text":"The bootstrap radial DEA model (Simar and Wilson, 1998) can be calculated with the deaboot function, indicating the number of bootstrap replications in the nreps parameter. The other parameters work the same as in the radial DEA model.\n\nA random number generator can be specified in the rng parameter for reproducibility.\n\nusing DataEnvelopmentAnalysis\nusing StableRNGs\n\nX = [2, 4, 3, 5, 6]\nY = [1, 2, 3, 4, 5]\n\nioboot = deaboot(X, Y, orient = :Input, rts = :VRS, nreps = 200, rng = StableRNG(1234567))\n\nwarning: Number of bootstrap replications\nThe example above uses 200 bootstrap replications for illustrative purposes. In practice, at least 1000 replications are recommended.\n\nBias-corrected efficiency scores are returned with the efficiency function:\n\nefficiency(ioboot)\n\nThe bias, calculated as the difference between the reference efficiency score and the bias-corrected efficiency score, is returned with the bias function:\n\nbias(ioboot)\n\nConfidence intervals at the 95, or any other desired level, are calculated with the confint function: \n\nconfint(ioboot, level = 0.95)\n\nThe optimal bandwidth computed for the model is returned with the bandwidth function:\n\nbandwidth(ioboot)","category":"section"},{"location":"statistical/radialboot/#deaboot-Function-Documentation","page":"Bootstrap Radial DEA Model","title":"deaboot Function Documentation","text":"","category":"section"},{"location":"statistical/radialboot/#DataEnvelopmentAnalysis.deaboot","page":"Bootstrap Radial DEA Model","title":"DataEnvelopmentAnalysis.deaboot","text":"deaboot(X, Y)\n\nCompute the bootstrap radial model using data envelopment analysis for inputs X and outputs Y.\n\nOptional Arguments\n\nnreps=200: number of bootstrap replications.\nrng=default_rng(): random number generator.\norient=:Input: chooses the radially oriented input mode. For the radially oriented output model choose :Output.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\ndisposX=:Strong: chooses strong disposability of inputs. For weak disposability choose :Weak.\ndisposY=:Strong: chooses strong disposability of outputs. For weak disposability choose :Weak.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"statistical/radialboot/#DataEnvelopmentAnalysis.bias-Tuple{BootstrapRadialDEAModel}","page":"Bootstrap Radial DEA Model","title":"DataEnvelopmentAnalysis.bias","text":"bias(model::BootstrapRadialDEAModel)\n\nReturn the bias from bootstrap DEA model.\n\n\n\n\n\n","category":"method"},{"location":"statistical/radialboot/#StatsAPI.confint-Tuple{BootstrapRadialDEAModel}","page":"Bootstrap Radial DEA Model","title":"StatsAPI.confint","text":"confint(model::BootstrapRadialDEAModel; level::Real=0.95)\n\nCompute confidence intervals for efficiency scores, with confidence level level (by default 95%).\n\n\n\n\n\n","category":"method"},{"location":"statistical/radialboot/#DataEnvelopmentAnalysis.bandwidth-Tuple{BootstrapRadialDEAModel}","page":"Bootstrap Radial DEA Model","title":"DataEnvelopmentAnalysis.bandwidth","text":"bandwidth(model::BootstrapRadialDEAModel)\n\nReturn the optimal bandwidth of a bootstrap DEA model.\n\n\n\n\n\n","category":"method"},{"location":"technical/enhancedrussell/#Enhanced-Russell-Graph-Slack-Based-Measure","page":"Enhanced Russell Graph Slack Based Measure","title":"Enhanced Russell Graph Slack Based Measure","text":"Based on the data  matrix (XY), we calculate the Enhanced Russell Graph Measure, ERG, (Pastor et al., 1999) – also known as the Slack Based Measure, SBM, Tone (2001) – of each observation o by solving n times the following linear programming problem:\n\nbeginaligned\n   undersetbeta t_i^- t_r^+ mu_j mathopmin quad quad quad  beta -  frac1m sum_i=1^mfract_i^-x_io  \n   textsubject textto  \n   quad quad quad quad quad  beta +  frac1s sum_r=1^sfract_r^+y_ro = 1 \n   quad quad quad quad quad  sum_j=1^nmu_j x_ij  = beta x_io - t_i^- qquad i = 1m \n   quad quad quad quad quad  sum_j=1^nmu_j y_rj  = beta y_ro + t_r^+ qquad r = 1s \n   quad quad quad quad quad  beta ge 0  \n   quad quad quad quad quad  t_i^- ge 0 qquad i = 1m \n   quad quad quad quad quad  t_r^+ ge 0 qquad r = 1s \n   quad quad quad quad quad  mu_j ge 0 qquad j = 1n \nendaligned\n\nwith the following condition when assuming variable returns to scale:\n\nsumnolimits_j=1^nmu_j=beta\n\nAfter solving the model, input and output slacks are recovered through the following expressions:\n\nbeginaligned\n  s_i^- = fract_i^-beta qquad i = 1m \n  s_r^+ = fract_r^+beta qquad r = 1s\nendaligned\n\nIn this example we compute the Enhanced Russell Graph DEA model under variable returns to scale:\n\nusing DataEnvelopmentAnalysis\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\ndeaergvrs = deaerg(X, Y, rts = :VRS)\n\nEstimated efficiency scores are returned with the efficiency function:\n\nefficiency(deaergvrs)\n\nEstimated beta's are returned with the efficiency function using :beta as the second argument:\n\nefficiency(deaergvrs, :beta)","category":"section"},{"location":"technical/enhancedrussell/#deaerg-Function-Documentation","page":"Enhanced Russell Graph Slack Based Measure","title":"deaerg Function Documentation","text":"","category":"section"},{"location":"technical/enhancedrussell/#DataEnvelopmentAnalysis.deaerg","page":"Enhanced Russell Graph Slack Based Measure","title":"DataEnvelopmentAnalysis.deaerg","text":"deaerg(X, Y)\n\nCompute data envelopment analysis Enhanced Russell Graph Slack Based Measure for inputs X and outputs Y.\n\nOptional Arguments\n\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"economic/profitability/#Profitability-Models","page":"Profitability Models","title":"Profitability Models","text":"","category":"section"},{"location":"economic/profitability/#Profitability-Model","page":"Profitability Models","title":"Profitability Model","text":"The profitabilty function defines as mathrmPleft(mathbfwmathbfpright)=max Big sumlimits_i=1^sp_iy_isumlimits_i=1^mw_ix_i   mathbfx geqslant Xmathbflambdamathbfy leqslant Ymathbflambda  lambda  geqslant mathbf0 Big. Zofío and Prieto (2006) introduced the following program that allows calculating profitability efficiency.\n\nbeginaligned\n  undersetmathbfxylambda_jomega mathopmin quad quad quad  omega  \n  textsubject textto \n  quad quad quad quad quad  sum_j=1^j lambda^j fracw^j x^jp^j y^j = omega fracw^j x^j_op^j y^j_o  \n  quad quad quad quad quad   sumnolimits_j=1^nlambda^j=1 \n  quad quad quad quad quad  mathbflambda ge mathbf0 \nendaligned\n\nProfitabilty efficiency defines as the ratio between maximum profitabilty and observed profitabilty. Following the duality results introduced by Zofío and Prieto (2006) it is possible to decompose it into technical and allocative efficiencies under constant returns to scale. Profitabilty efficiency can be then decomposed into the generalizaed distance fucntion and the residual ratio corresponding to the allocative profit efficiency. Allocative efficiency defines then as the ratio of profitability at the technically efficient projection on the frontier to maximum profitability.\n\nIn this example we compute the profitability efficiency measure:\n\nusing DataEnvelopmentAnalysis\n\nX = [5 3; 2 4; 4 2; 4 8; 7 9.0];\n\nY = [7 4; 10 8; 8 10; 5 4; 3 6.0];\n\nW = [2 1; 2 1; 2 1; 2 1; 2 1.0];\n\nP = [3 2; 3 2; 3 2; 3 2; 3 2.0];\n\ndeaprofitability(X, Y, W, P)","category":"section"},{"location":"economic/profitability/#deaprofitability-Function-Documentation","page":"Profitability Models","title":"deaprofitability Function Documentation","text":"","category":"section"},{"location":"economic/profitability/#DataEnvelopmentAnalysis.deaprofitability","page":"Profitability Models","title":"DataEnvelopmentAnalysis.deaprofitability","text":"deaprofitability(X, Y, W, P)\n\nCompute profitability efficiency using data envelopment analysis for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nOptional Arguments\n\nalpha=0.5: alpha to use for the generalized distance function.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"technical/holder/#Hölder-Distance-Function-Models","page":"Hölder Distance Function","title":"Hölder Distance Function Models","text":"Briec (1998) defined technical inefficiency using Hölder norms.","category":"section"},{"location":"technical/holder/#Hölder-L1","page":"Hölder Distance Function","title":"Hölder L1","text":"In this example we compute the Hölder L1 DEA model under varible returns to scale:\n\nusing DataEnvelopmentAnalysis\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\ndeaholder(X, Y, l = 1, rts = :VRS)\n\nEstimated efficiency scores are returned with the efficiency function:\n\nholderl1 = deaholder(X, Y, l = 1, rts = :VRS);\n\nefficiency(holderl1)\n\nThe input or output that determines the projection to the frontier is returned with:\n\nefficiency(holderl1, :min)\n\nwith inputs and outputs numbered sequentially.","category":"section"},{"location":"technical/holder/#Hölder-L2","page":"Hölder Distance Function","title":"Hölder L2","text":"warning: Requieres a solver that supports SOS constraints\nThe Hölder L2 model requieres a solver that supports SOS constraints, such as Gurobi. Solving the model with Ipopt will return invalid results.","category":"section"},{"location":"technical/holder/#Hölder-LInf","page":"Hölder Distance Function","title":"Hölder LInf","text":"In this example we compute the Hölder LInf DEA model under varible returns to scale:\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\ndeaholder(X, Y, l = Inf, rts = :VRS)","category":"section"},{"location":"technical/holder/#deaholder-Function-Documentation","page":"Hölder Distance Function","title":"deaholder Function Documentation","text":"","category":"section"},{"location":"technical/holder/#DataEnvelopmentAnalysis.deaholder","page":"Hölder Distance Function","title":"DataEnvelopmentAnalysis.deaholder","text":"deaholder(X, Y; l)\n\nCompute the Hölder distance function model using data envelopment analysis for inputs X and outputs Y,  using Hölder norm l.\n\nHölder norm l specification\n\n1.\n2.\nInf.\n\nOptional Arguments\n\nweigt=false:  set to true for weighted (weakly) Hölder distance function.\norient=:Input: chooses the radially oriented input mode. For the radially oriented output model choose :Output.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nslack=true: computes input and output slacks.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"technical/generalizeddf/#Generalized-Distance-Function-Models","page":"Generalized Distance Function Models","title":"Generalized Distance Function Models","text":"Chavas and Cox (1999) introduced a generalized distance function efficiency measure that reescales both inputs and outputs toward the frontier technology.\n\nbeginaligned\n  undersetdelta mathbflambda mathopmin quad quad quad  delta  \n  textsubject textto \n  quad quad quad quad quad  Xmathbflambda  le delta^1 - alpha mathbfx_o \n  quad quad quad quad quad  Ymathbflambda  ge mathbfy_o  delta^alpha \n  quad quad quad quad quad  mathbflambda ge mathbf0 \nendaligned\n\nThe measurement of technical efficiency assuming variable returns to scale, VRS, adds the following condition:\n\nsumnolimits_j=1^nlambda_j=1\n\nIn this example we compute the generalized distance function DEA model under variable returns to scale using 05 for the value of alpha:\n\nusing DataEnvelopmentAnalysis\n\nX = [5 3; 2 4; 4 2; 4 8; 7 9];\n\nY = [7 4; 10 8; 8 10; 5 4; 3 6];\n\ndeagdf(X, Y, alpha = 0.5, rts = :VRS, slack = false)","category":"section"},{"location":"technical/generalizeddf/#deagdf-Function-Documentation","page":"Generalized Distance Function Models","title":"deagdf Function Documentation","text":"","category":"section"},{"location":"technical/generalizeddf/#DataEnvelopmentAnalysis.deagdf","page":"Generalized Distance Function Models","title":"DataEnvelopmentAnalysis.deagdf","text":"deagdf(X, Y, alpha)\n\nCompute generalized distance function data envelopment analysis model for inputs X, outputs Y, and alpha.\n\nOptional Arguments\n\nalpha=0.5: alpha value.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nslack=true: compute input and output slacks.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"technical/environmental/#Environmental-Model","page":"Environmental Model","title":"Environmental Model","text":"In this example we compute the Aparicio, Pastor and Zofio (2023) environmental model for inputs X, good outputs Y, and bad outputs B, using directions Gx, Gy, and Gb. If not specified, default directions are Gx = :Zeros, Gy = :Observed, Gb = :Observed.\n\nusing DataEnvelopmentAnalysis\n\nX = ones(5, 1);\nY = [7; 5; 1; 3; 4];\nB = [2; 5; 3; 3; 2];\n\ndeaenv1 = deaenv(X, Y, B)\n\nEstimated efficiency scores are returned with the efficiency function:\n\nefficiency(deaenv1)\n\nThe optimal peers, λ, are returned with the peers function and are returned as a DEAPeers object:\n\npeers(deaenv1)","category":"section"},{"location":"technical/environmental/#deaenv-Function-Documentation","page":"Environmental Model","title":"deaenv Function Documentation","text":"","category":"section"},{"location":"technical/environmental/#DataEnvelopmentAnalysis.deaenv","page":"Environmental Model","title":"DataEnvelopmentAnalysis.deaenv","text":"deaenv(X, Y, B; Gx, Gy, Gb)\n\nCompute data envelopment analysis environmental model for inputs X, good outputs Y, and bad outputs B, using directions Gx, Gy, and Gb.\n\nDirection specification:\n\nThe directions Gx, Gy, and Gb can be one of the following symbols.\n\n:Zeros: use zeros.\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nslack=true: computes input and output slacks.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of good outputs against which the units are evaluated.\nBref=B: Identifies the reference set of bad outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"economic/profit/#Profit-Models","page":"Profit Models","title":"Profit Models","text":"","category":"section"},{"location":"economic/profit/#Profit-Efficiency-Model-with-Directional-Distance-Function-Technical-Efficiency","page":"Profit Models","title":"Profit Efficiency Model with Directional Distance Function Technical Efficiency","text":"The profit function defines as Pileft(mathbfwmathbfpright)=max Big sumlimits_i=1^sp_iy_i-sumlimits_i=1^mw_ix_i      mathbfx geqslant Xmathbflambdamathbfy leqslant Ymathbflambda mathbfmathbfelambda=1 lambda  geqslant mathbf0 Big. Calculating maximum profit along with the optimal output and input quantities mathbfy^*and mathbfx^* requires solving:\n\nbeginaligned\n  undersetmathbfxylambda mathopmax quad quad quad  Pileft(mathbfwmathbfpright)=mathbfpy^*-wx^*  \n  textsubject textto \n  quad quad quad quad quad  mathbfxge Xmathbflambda=x  \n  quad quad quad quad quad   mathbfy  le Ymathbflambda =y \n  quad quad quad quad quad  mathbfelambda=1 \n  quad quad quad quad quad  mathbflambda ge mathbf0  \nendaligned\n\nProfit efficiency defines as the difference between maximum profit and observed profit. Following the duality results introduced by Chambers, Chung and Färe (1998) it is possible to decompose it into technical and allocative efficiencies under variable returns to scale. Profit efficiency can be then decomposed into the directional distance fucntion and the residual difference corresponding to the allocative profit efficiency. Allocative efficiency defines then as the difference between maximum profit and profit at the technically efficient projection on the frontier. The approach relies on the directional vector to normalize these components, thereby ensuring that their values can be compared across DMUs.\n\nIn this example we compute the profit efficiency measure under variable returns to scale:\n\nusing DataEnvelopmentAnalysis\n\nX = [1 1; 1 1; 0.75 1.5; 0.5 2; 0.5 2; 2 2; 2.75 3.5; 1.375 1.75];\n\nY = [1 11; 5 3; 5 5; 2 9; 4 5; 4 2; 3 3; 4.5 3.5];\n\nP = [2 1; 2 1; 2 1; 2 1; 2 1; 2 1; 2 1; 2 1];\n\nW = [2 1; 2 1; 2 1; 2 1; 2 1; 2 1; 2 1; 2 1];\n\ndeaprofit(X, Y, W, P, Gx = :Monetary, Gy = :Monetary)","category":"section"},{"location":"economic/profit/#deaprofit-Function-Documentation","page":"Profit Models","title":"deaprofit Function Documentation","text":"","category":"section"},{"location":"economic/profit/#DataEnvelopmentAnalysis.deaprofit","page":"Profit Models","title":"DataEnvelopmentAnalysis.deaprofit","text":"deaprofit(X, Y, W, P; Gx, Gy)\n\nCompute profit efficiency using data envelopment analysis model for inputs X, outputs Y, price of inputs W, and price of outputs P.\n\nDirection specification:\n\nThe directions Gx and Gy can be one of the following symbols.\n\n:Zeros: use zeros.\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n:Monetary: use direction so that profit inefficiency is expressed in monetary values.\n:Euclidean: use prices normalized by the Euclidean norm of all input and output prices so profit inefficiency is the Euclidean distance between profit hyperplanes.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nmonetary=false: decomposition in normalized terms. Monetary terms if true.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"technical/commontechnical/#Common-functions-for-technical-models","page":"Common functions for technical models","title":"Common functions for technical models","text":"","category":"section"},{"location":"technical/commontechnical/#StatsAPI.nobs-Tuple{AbstractDEAModel}","page":"Common functions for technical models","title":"StatsAPI.nobs","text":"nbos(model::Abstract DEAModel)\n\nReturn number of observations of a DEA model.\n\n\n\n\n\n","category":"method"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.ninputs-Tuple{AbstractDEAModel}","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.ninputs","text":"ninputs(model::AbstractDEAModel)\n\nReturn number of inputs of a DEA model.\n\n\n\n\n\n","category":"method"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.noutputs-Tuple{AbstractDEAModel}","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.noutputs","text":"noutputs(model::AbstractDEAModel)\n\nReturn number of outputs of a DEA model.\n\n\n\n\n\n","category":"method"},{"location":"technical/commontechnical/#Base.names-Tuple{AbstractDEAModel}","page":"Common functions for technical models","title":"Base.names","text":"names(model::AbstractDEAModel)\n\nReturn the names of the decision making units (DMUs)\n\n\n\n\n\n","category":"method"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.efficiency-Tuple{AbstractTechnicalDEAModel}","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.efficiency","text":"efficiency(model::AbstractTechnicalDEAModel)\n\nReturn efficiency scores of a technical DEA model.\n\n\n\n\n\n","category":"method"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.slacks","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.slacks","text":"slacks(model::AbstractTechnicalDEAModel, slack::Symbol)\n\nReturn slacks of a technical DEA model.\n\n\n\n\n\n","category":"function"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.targets-Tuple{AbstractTechnicalDEAModel, Symbol}","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.targets","text":"targets(model::AbstractTechnicalDEAModel, target::Symbol)\n\nReturn targets of a technical DEA model.\n\n\n\n\n\n","category":"method"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.peers","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.peers","text":"peers(model::AbstractDEAModel)\n\nReturn peers of a DEA model.\n\nOptional Arguments\n\natol=1e-10: tolerance for zero values.\nnamesref: a vector of strings with the names of the decision making units in the reference set.\n\n\n\n\n\n","category":"function"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.peersmatrix","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.peersmatrix","text":"peersmatrix(model::AbstractDEAModel)\n\nReturn peers matrix of a DEA model.\n\n\n\n\n\n","category":"function"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.ispeer","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.ispeer","text":"ispeer(P::DEAPeers, i::Int64, j::Int64)\n\nReturn true if j is peer of decision making unit i.\n\n\n\n\n\nispeer(P::DEAPeers, i::String, j::String)\n\nReturn true if j is peer of decision making unit i.\n\n\n\n\n\nispeer(P::DEAPeersDMU, j::Int64)\n\nReturn true if j is peer.\n\n\n\n\n\nispeer(P::DEAPeers, j::String)\n\nReturn true if j is peer.\n\n\n\n\n\n","category":"function"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.multipliers","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.multipliers","text":"multipliers(model::AbstractTechnicalDEAModel, multiplier::Symbol)\n\nReturn multipliers (shadow prices) of a technical DEA model.\n\n\n\n\n\n","category":"function"},{"location":"technical/commontechnical/#DataEnvelopmentAnalysis.rts","page":"Common functions for technical models","title":"DataEnvelopmentAnalysis.rts","text":"rts(model::AbstractTechnicalDEAModel)\n\nReturn the value measuring the returns to scale of a multiplier DEA model.\n\n\n\n\n\n","category":"function"},{"location":"optimizer/#Configuring-the-optimizer","page":"Configuring Optimizer","title":"Configuring the optimizer","text":"DataEnvelopmentAnalysis.jl will use a default optimizer/solver for each DEA model, as shown in the next table.\n\nFunction Specific Options Problem type Default Optimizer\ndea  LP GLPK\ndeam  LP GLPK\ndeaboot  LP GLPK\ndeabigdata  LP GLPK\ndeaddf  LP GLPK\ndeaadd  LP GLPK\ndeagdf  NLP Ipopt\ndearussell :Input or :Output LP GLPK\ndearussell :Graph NLP Ipopt\ndeaerg  LP GLPK\ndeamddf  LP GLPK\ndeaholder l = 1 LP GLPK\ndeaholder l = 2 QP \ndeaholder l = Inf LP GLPK\ndearddf :ERG LP GLPK\ndearddf :MDDF LP GLPK\ndeaenv  LP GLPK\ndeacost  LP GLPK\ndearevenue  LP GLPK\ndeaprofit  LP GLPK\ndeaprofitability  NLP Ipopt\nmalmquist  LP GLPK\nmalmluen  LP GLPK\n\nWhere:\n\nLP = Linear programming.\nNLP = Nonlinear programming.\nQP = Quadratic programming.\n\nModels can be solved using a different optimizer by passing a DEAOptimizer object to the optimizer optional argument. See JuMP documentation for a list of all available solvers.\n\nwarning: Choose a valid optimizer\nThe optimizer must support the problem type of the DEA model.For example, you cannot solve a Generalized Distance Function DEA model using the GLPK solver because it is a linear programming solver and deagdf requires a nonlinear programming solver.\n\nThe following is an example of solving the radial DEA model using the Ipopt sovler:\n\nusing Ipopt\nusing DataEnvelopmentAnalysis\n\nX = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\nY = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\nmyoptimizer = DEAOptimizer(Ipopt.Optimizer, time_limit = 10, silent = true);\n\ndea(X, Y, slack = false, optimizer = myoptimizer)","category":"section"},{"location":"optimizer/#Optimizer-API","page":"Configuring Optimizer","title":"Optimizer API","text":"","category":"section"},{"location":"optimizer/#DataEnvelopmentAnalysis.DEAOptimizer","page":"Configuring Optimizer","title":"DataEnvelopmentAnalysis.DEAOptimizer","text":"DEAOptimizer(optimizer; time_limit, silent)\n\nAn data structure storing the configuration of a DEA optimizer.\n\nOptimizer specification:\n\nLP: linear programming default optimizer, GLPK.\nNLP: nonlinear programmin default optimizer, Ipopt.\nAny JuMP supported solver.\n\nOptional Arguments\n\ntime_limit=:60: time limit in seconds.\nsilent=true: suppress optimizer output.\n\n\n\n\n\n","category":"type"},{"location":"optimizer/#DataEnvelopmentAnalysis.newdeamodel","page":"Configuring Optimizer","title":"DataEnvelopmentAnalysis.newdeamodel","text":"newdeamodel(DEAOptimizer)\n\nGenerate a new JuMP model for DEA with the specified optimizer.\n\nThis function is used internally and for packages that want to extend the functionality of this package.\n\n\n\n\n\n","category":"function"},{"location":"economic/revenue/#Revenue-Models","page":"Revenue Models","title":"Revenue Models","text":"","category":"section"},{"location":"economic/revenue/#Revenue-Efficiency-Model-with-Radial-Technical-Efficiency","page":"Revenue Models","title":"Revenue Efficiency Model with Radial Technical Efficiency","text":"Let us denote by Rleft(mathbfxmathbfpright) the maximum feasible revenue using inputs' levels mathbfx and given the outputs' prices mathbfp: Rleft(mathbfxmathbfpright)=max left sumlimits_i=1^sp_iy_i  mathbfx_o geqslant Xmathbflambdamathbfy leqslant Ymathbflambda mathbflambda  geqslant mathbf0 right; i.e.,  considering the output possibility set producible with mathbfx_o. In this case, we calculate maximum revenue along with the optimal output quantities mathbfy^*  by solving the following program:\n\nbeginaligned\n  undersetmathbfy mathbflambda mathopmax quad quad quad  Rleft(mathbfx_omathbfpright)=mathbfpy^*   \n  textsubject textto  \n  quad quad quad quad quad  mathbfx_oge Xmathbflambda   \n  quad quad quad quad quad  Ymathbflambda  ge mathbfy  \n  quad quad quad quad quad  mathbflambda ge mathbf0 \nendaligned\n\nThe measurement of revenue efficiency assuming variable returns to scale, VRS, adds the following condition:\n\nsumnolimits_j=1^nlambda_j=1\n\nRevenue efficiency defines as the ratio of observed revenue to maximum revenue: RE=mathbfpy_oRleft(mathbfxmathbfpright)  Duality results presented in *Shephard (1953)* from an output perspective allow us to decompose RE into the output oriented technical efficiency measure and the residual difference corresponding to the allocative revenue efficiency. Allocative efficiency defines as the ratio of revenue at the technically efficient projection of the observation to maximum revenue.\n\nIn this example we compute the revnue efficiency measure under variable returns to scale:\n\nusing DataEnvelopmentAnalysis\n\nX = [5 3; 2 4; 4 2; 4 8; 7 9.0];\n\nY = [7 4; 10 8; 8 10; 5 4; 3 6.0];\n\nP = [3 2; 3 2; 3 2; 3 2; 3 2.0];\n\ndearevenue(X, Y, P)","category":"section"},{"location":"economic/revenue/#dearevenue-Function-Documentation","page":"Revenue Models","title":"dearevenue Function Documentation","text":"","category":"section"},{"location":"economic/revenue/#DataEnvelopmentAnalysis.dearevenue","page":"Revenue Models","title":"DataEnvelopmentAnalysis.dearevenue","text":"dearevenue(X, Y, P)\n\nCompute revenue efficiency using data envelopment analysis for inputs X, outputs Y and price of outputs P.\n\nOptional Arguments\n\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\ndispos=:Strong: chooses strong disposability of inputs. For weak disposability choose :Weak.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"productivity/malmquistluenberger/#The-Malmquist-Luenberger-index","page":"Malmquist-Luenberger","title":"The Malmquist-Luenberger index","text":"","category":"section"},{"location":"productivity/malmquistluenberger/#The-Malmquist-Luenberger-Productivity-Index","page":"Malmquist-Luenberger","title":"The Malmquist-Luenberger Productivity Index","text":"The Malmquist-Luenberger index (Chung, Färe and Grosskopf, 1997, and Aparicio, Pastor and Zofío, 2013) measures the change in  productivity of the observation under evaluation by comparing its relative performance with respect to  reference  technologies corresponding to two different time periods. Productivity change can be decomposed into efficiency change and technical change under the assumption of a constant returns to scale techncology.\n\nIn this example we compute the Malmquist-Luenberger productivity index for inputs X, good outputs Y, and bad outputs B, using directions Gx, Gy, and Gb. If not specified, default directions are Gx = :Zeros, Gy = :Observed, Gb = :Observed. If not specified, default directions are Gx = :Zeros, Gy = :Observed, Gb = :Observed.\n\nusing DataEnvelopmentAnalysis\n\nX = Array{Float64,3}(undef, 5, 1, 2)\nY = Array{Float64,3}(undef, 5, 1, 2)\nB = Array{Float64,3}(undef, 5, 1, 2)\n\nX[:,:,1] = ones(5, 1);\nX[:,:,2] = ones(5, 1);\n\nY[:,:,1] = [7; 5; 1; 3; 4];\nY[:,:,2] = [8; 5.5; 2; 2; 4];\n\nB[:,:,1] = [2; 5; 3; 3; 2];\nB[:,:,2] = [1; 3; 2; 4; 1];\n\nmlprod = malmluen(X, Y, B)","category":"section"},{"location":"productivity/malmquistluenberger/#malmluen-Function-Documentation","page":"Malmquist-Luenberger","title":"malmluen Function Documentation","text":"","category":"section"},{"location":"productivity/malmquistluenberger/#DataEnvelopmentAnalysis.malmluen","page":"Malmquist-Luenberger","title":"DataEnvelopmentAnalysis.malmluen","text":"malmluen(X, Y, B; Gx, Gy, Gb)\n\nCompute the Malmquist-Luenberger productivity index using data envelopment analysis for inputs X,  good outputs Y, and bad outputs B, using directions Gx, Gy, and Gb.\n\nDirection specification:\n\nThe directions Gx, Gy, and Gb can be one of the following symbols.\n\n:Zeros: use zeros.\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n\nOptional Arguments\n\nrefperiod=:Geomean: chooses reference period for technological change: :Base, :Comparison or :Geomean.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"technical/modifiedddf/#Modified-Directional-Distance-Function","page":"Modified Directional Distance Function","title":"Modified Directional Distance Function","text":"Based on the data  matrix (XY), we calculate the modified directional distance function MDDF, (Aparicio et al. 2013), of each observation o by solving n times the following linear programming problem:\n\nbeginaligned\n   undersetbeta^x beta^ylambda_j mathopmin quad quad quad  beta^x + beta^y   \n   textsubject textto  \n   quad quad quad quad quad  sum_j=1^nlambda_j x_ij  le x_io - beta^x g_io^- qquad i = 1m  \n   quad quad quad quad quad  sum_j=1^nlambda_j y_rj  ge y_ro + beta^y g_ro^+ qquad r = 1s \n   quad quad quad quad quad  lambda_j ge 0 qquad j = 1n  \n   quad quad quad quad quad  beta^x ge 0 qquad i = 1m  \n   quad quad quad quad quad  beta^y ge 0 qquad r = 1s  \nendaligned\n\nwith the following condition when assuming variable returns to scale:\n\nsumnolimits_j=1^nlambda_j=1\n\nIn this example we compute the modified directional distance function model under variable returns to scale using ones as directions for both inputs and outputs::\n\nusing DataEnvelopmentAnalysis\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\ndeamddfvrs = deamddf(X, Y, Gx = :Ones, Gy = :Ones, rts = :VRS)\n\nEstimated efficiency scores are returned with the efficiency function:\n\nefficiency(deamddfvrs)\n\nEstimated beta on inputs and outputs are returned with the efficiency function:\n\nefficiency(deamddfvrs, :X)\n\nefficiency(deamddfvrs, :Y)","category":"section"},{"location":"technical/modifiedddf/#deamddf-Function-Documentation","page":"Modified Directional Distance Function","title":"deamddf Function Documentation","text":"","category":"section"},{"location":"technical/modifiedddf/#DataEnvelopmentAnalysis.deamddf","page":"Modified Directional Distance Function","title":"DataEnvelopmentAnalysis.deamddf","text":"deamddf(X, Y; Gx, Gy)\n\nCompute data envelopment analysis modified directional distance function model for inputs X and outputs Y, using directions Gx and Gy.\n\nDirection specification:\n\nThe directions Gx and Gy can be one of the following symbols.\n\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nslack=true: computes input and output slacks.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"productivity/commonproductivity/#Common-functions-for-productivity-change-models","page":"Common functions for productivity change models","title":"Common functions for productivity change models","text":"","category":"section"},{"location":"productivity/commonproductivity/#DataEnvelopmentAnalysis.nperiods","page":"Common functions for productivity change models","title":"DataEnvelopmentAnalysis.nperiods","text":"nperiods(model::AbstractProductivityDEAModel)\n\nReturn number of time periods of a productivity DEA model.\n\n\n\n\n\n","category":"function"},{"location":"productivity/commonproductivity/#DataEnvelopmentAnalysis.prodchange","page":"Common functions for productivity change models","title":"DataEnvelopmentAnalysis.prodchange","text":"prodchange(model::AbstractProductivityDEAModel)\n\nReturn productivity change of a productivity change DEA model.\n\n\n\n\n\n","category":"function"},{"location":"productivity/malmquist/#The-Malmquist-index","page":"Malmquist Index","title":"The Malmquist index","text":"","category":"section"},{"location":"productivity/malmquist/#The-Malmquist-Productivity-Index","page":"Malmquist Index","title":"The Malmquist Productivity Index","text":"The Malmquist index introduced by Caves, Christensen and Diewert(1982) measures the change in  productivity of the observation under evaluation by comparing its relative performance with respect to  reference  technologies corresponding to two different time periods.\n\nFollowing Fare, Grosskopf, Norris and Zhang (1994) productivity change can be decomposed into efficiency change and technical change under the assumption of a constant returns to scale techncology.\n\nIn this example we compute the Malmquist productivity index:\n\nusing DataEnvelopmentAnalysis\n\nX = Array{Float64,3}(undef, 5, 1, 2);\nX[:, :, 1] = [2; 3; 5; 4; 4];\nX[:, :, 2] = [1; 2; 4; 3; 4];\n\nY = Array{Float64,3}(undef, 5, 1, 2);\nY[:, :, 1] = [1; 4; 6; 3; 5];\nY[:, :, 2] = [1; 4; 6; 3; 3];\n\nmalmquist(X, Y)","category":"section"},{"location":"productivity/malmquist/#malmquist-Function-Documentation","page":"Malmquist Index","title":"malmquist Function Documentation","text":"","category":"section"},{"location":"productivity/malmquist/#DataEnvelopmentAnalysis.malmquist","page":"Malmquist Index","title":"DataEnvelopmentAnalysis.malmquist","text":"malmquist(X, Y)\n\nCompute the Malmquist productivity index using data envelopment analysis for inputs X and outputs Y.\n\nOptional Arguments\n\norient=:Input: chooses between input oriented radial model :Input or output oriented radial model :Output.\nrefperiod=:Geomean: chooses reference period for technological change: :Base, :Comparison or :Geomean.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"technical/directional/#Directional-Distance-Function-Models","page":"Directional Distance Function Models","title":"Directional Distance Function Models","text":"Chambers, Chung and Fare (1996) introduced a measure of efficiency that projects observation left( mathbfx_omathbfy_o right) in a pre-assigned  direction  mathbfg= left(-mathbfg_x^-mathbfg^+_y right)neqmathbf0_m+s, mathbfg^-_xmathbbin R^m and  mathbfg^+_ymathbbin R^s, in a proportion beta. The associated linear program is:\n\nbeginaligned\n  undersetbeta mathbflambda mathopmax quad quad quad quad beta  \n  textsubject textto \n  quad quad quad quad quad  Xlambdale mathbfx_o -betamathbfg^-_x \n  quad quad quad quad quad   Ymathbflambda ge mathbfy_o+beta mathbfg^+_y  \n  quad quad quad quad quad  mathbflambda ge mathbf0   quad \nendaligned\n\nThe measurement of technical efficiency assuming variable returns to scale, VRS, adds the following condition:\n\nsumnolimits_j=1^nlambda_j=1\n\nIn this example we compute the directional distance function DEA model under constant returns to scale using ones as directions for both inputs and outputs:\n\nusing DataEnvelopmentAnalysis\n\nX = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\nY = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\ndeaddf(X, Y, Gx = :Ones, Gy = :Ones)\n\nTo compute the variable returns to scale model, we simply set the rts parameter to :VRS:\n\ndeaddfvrs = deaddf(X, Y, Gx = :Ones, Gy = :Ones, rts = :VRS)\n\nEstimated efficiency scores are returned with the efficiency function:\n\nefficiency(deaddfvrs)\n\nThe optimal peers, λ, are returned with the peers function and are returned as a DEAPeers object:\n\npeers(deaddfvrs)","category":"section"},{"location":"technical/directional/#Directional-Distance-Function-Model-in-Multiplier-Form","page":"Directional Distance Function Models","title":"Directional Distance Function Model in Multiplier Form","text":"The dual to the directional distance function DEA model in envelopment form presented above is the multiplier form.\n\nThis example computes the directional distance function models DEA model in multiplier form under variable returns to scale:\n\nddfonesm = deaddfm(X, Y, Gx = :Ones, Gy = :Ones, rts = :VRS)\n\nInput and output virtual multipliers (shadow prices) are returned with the multipliers function:\n\nmultipliers(ddfonesm, :X)\n\nmultipliers(ddfonesm, :Y)\n\nThe value measuring the returns to scale is returned with the rts function:\n\nrts(ddfonesm)","category":"section"},{"location":"technical/directional/#deaddf-Function-Documentation","page":"Directional Distance Function Models","title":"deaddf Function Documentation","text":"","category":"section"},{"location":"technical/directional/#DataEnvelopmentAnalysis.deaddf","page":"Directional Distance Function Models","title":"DataEnvelopmentAnalysis.deaddf","text":"deaddf(X, Y; Gx, Gy)\n\nCompute data envelopment analysis directional distance function model for inputs X and outputs Y, using directions Gx and Gy.\n\nDirection specification:\n\nThe directions Gx and Gy can be one of the following symbols.\n\n:Zeros: use zeros.\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nslack=true: computes input and output slacks.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"technical/directional/#DataEnvelopmentAnalysis.deaddfm","page":"Directional Distance Function Models","title":"DataEnvelopmentAnalysis.deaddfm","text":"deaddfm(X, Y; Gx, Gy)\n\nCompute data envelopment analysis directional distance function multiplier model for inputs X and outputs Y, using directions Gx and Gy.\n\nDirection specification:\n\nThe directions Gx and Gy can be one of the following symbols.\n\n:Zeros: use zeros.\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n\nAlternatively, a vector or matrix with the desired directions can be supplied.\n\nOptional Arguments\n\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"economic/commoneconomic/#Common-functions-for-economic-models","page":"Common functions for economic models","title":"Common functions for economic models","text":"","category":"section"},{"location":"economic/commoneconomic/#DataEnvelopmentAnalysis.efficiency-Tuple{AbstractEconomicDEAModel, Symbol}","page":"Common functions for economic models","title":"DataEnvelopmentAnalysis.efficiency","text":"efficiency(model::AbstractEconomicDEAModel)\n\nReturn efficiency scores of an economic DEA model.\n\nOptional Arguments\n\ntype=Economic: type of efficiency scores to return.\n\nType specification:\n\n:Economic: returns economic efficiency of the model.\n:Technical: returns technical efficiency.\n:Allocative: returns allocative efficiency.\n\nSome models also allow these types:\n\n:CRS: returns technical efficiency under constant returns to scale.\n:VRS: returns technical efficiency under variable returns to scale.\n:Scale: returns scale efficiency.\n\n\n\n\n\n","category":"method"},{"location":"economic/commoneconomic/#DataEnvelopmentAnalysis.targets-Tuple{AbstractEconomicDEAModel, Symbol}","page":"Common functions for economic models","title":"DataEnvelopmentAnalysis.targets","text":"targets(model::AbstractEconomicDEAModel, target::Symbol)\n\nReturn targets of an economic DEA model.\n\n\n\n\n\n","category":"method"},{"location":"economic/commoneconomic/#DataEnvelopmentAnalysis.normfactor","page":"Common functions for economic models","title":"DataEnvelopmentAnalysis.normfactor","text":"normfactor(model::AbstractEconomicDEAModel)\n\nReturn the normalization factor of an economic DEA model.\n\n\n\n\n\n","category":"function"},{"location":"economic/commoneconomic/#DataEnvelopmentAnalysis.ismonetary-Tuple{AbstractEconomicDEAModel}","page":"Common functions for economic models","title":"DataEnvelopmentAnalysis.ismonetary","text":"ismonetary(model::AbstractEconomicDEAModel)\n\nIndicate whether inefficiency is in monetary units.\n\n\n\n\n\n","category":"method"},{"location":"technical/additive/#Additive-Models","page":"Additive Models","title":"Additive Models","text":"","category":"section"},{"location":"technical/additive/#Weighted-Additive-Model","page":"Additive Models","title":"Weighted Additive Model","text":"The additive model measures technical efficiency based solely on input excesses and output shortfalls, and characterizes efficiency in terms of the input and output slacks: mathbfs^-mathbbin R^m and mathbfs^+mathbbin R^s, respectively. . The package implements the weighted additive formulation of Cooper and Pastor (1995) and Pastor, Lovell and Aparicio (2011), whose associated linear program is:\n\nbeginaligned\n   undersetmathbflambda mathbfs^-mathbfs^+mathopmax quad quad quad quad omega =mathbfrho_x^-mathbfs^mathbf-+mathbfrho_y^+mathbfs^+ \n  textsubject textto \n  quad quad quad quad quad quad Xmathbflambda +mathbfs^mathbf-=  mathbfx_o \n  quad quad quad quad quad quad Ymathbflambda -mathbfs^+= mathbfy_o \n  quad quad quad quad quad quad mathbfelambda=1 \n  quad quad quad quad quad quad mathbflambda ge mathbf0 mathbfs^mathbf-ge 0mathbfs^+ge 0 \nendaligned\n\nwhere (mathbfrho_x^- mathbfrho_y^+) mathbbin R^m_+times mathbbR_+^s are the inputs and outputs weight vectors whose elements can vary across DMUs.\n\nIn this example we compute the additive DEA model with all weights equal to one:\n\nusing DataEnvelopmentAnalysis\n\nX = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\nY = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\ndeaadd(X, Y)\n\nThe same model is computed with:\n\ndeaadd(X, Y, :Ones)\n\nThe additive DEA model can be computed under constant returns to scale setting the rts parameter to :CRS:\n\ndeaadd(X, Y, :Ones, rts = :CRS)\n\nThe package can compute a wide class of different DEA models known as general  efficiency measures (GEMs):\n\nThe measure of inefficiency proportions (MIP).\nThe normalized weighted additive DEA model.\nThe range adjusted measure (RAM).\nThe bounded adjusted  measure (BAM).","category":"section"},{"location":"technical/additive/#Measure-of-Inefficiency-Proportions-(MIP)","page":"Additive Models","title":"Measure of Inefficiency Proportions (MIP)","text":"The measure of inefficiency proportions (MIP), Charnes et al. (1987) and Cooper et al. (1999), use the weights:\n\n(mathbfrho_x^- mathbfrho_y^+)=(1mathbfx_o1mathbfy_o)\n\ndeaadd(X, Y, :MIP)","category":"section"},{"location":"technical/additive/#Normalized-Weighted-Additive-Model","page":"Additive Models","title":"Normalized Weighted Additive Model","text":"The normalized weighted additive DEA model, Lovell and Pastor (1995), use the weights:\n\n(mathbfrho_x^- mathbfrho_y^+)=(1mathbfσ^-1mathbfσ^+)\n\nwhere mathbfσ^-and mathbfσ^+ are the standard deviations of inputs and outputs respectively.\n\ndeaadd(X, Y, :Normalized)","category":"section"},{"location":"technical/additive/#Range-Adjusted-Measure-(RAM)","page":"Additive Models","title":"Range Adjusted Measure (RAM)","text":"The range adjusted measure (RAM), Cooper et al. (1999), use the weights::\n\n(mathbfrho^- mathbfrho^+)=(1(m+s)R^-(1(m+s)R^+)\n\nwhere R^-and R^+are the inputs and outputs variables' ranges.\n\ndeaadd(X, Y, :RAM)","category":"section"},{"location":"technical/additive/#Bounded-Adjusted-Measure-(BAM)","page":"Additive Models","title":"Bounded Adjusted  Measure (BAM)","text":"The bounded adjusted  measure (BAM), Cooper et al. (2011), use the weights:::\n\n(mathbfrho_x^- mathbfrho_y^+)=(1(m+s)(mathbfx_o-mathbfunderlinex)(1(m+s)(mathbfoverliney - mathbfy_o)\n\nwhere mathbfunderlinex and mathbfoverliney are the minimum and maximum observed values of inputs and outputs respectively.\n\ndeaadd(X, Y, :BAM)","category":"section"},{"location":"technical/additive/#deaadd-Function-Documentation","page":"Additive Models","title":"deaadd Function Documentation","text":"","category":"section"},{"location":"technical/additive/#DataEnvelopmentAnalysis.deaadd","page":"Additive Models","title":"DataEnvelopmentAnalysis.deaadd","text":"deaadd(X, Y, model)\n\nCompute related data envelopment analysis weighted additive models for inputs X and outputs Y.\n\nModel specification:\n\n:Ones: standard additive DEA model.\n:MIP: Measure of Inefficiency Proportions. (Charnes et al., 1987; Cooper et al., 1999)\n:Normalized: Normalized weighted additive DEA model. (Lovell and Pastor, 1995)\n:RAM: Range Adjusted Measure. (Cooper et al., 1999)\n:BAM: Bounded Adjusted Measure. (Cooper et al, 2011)\n:Custom: User supplied weights.\n\nOptional Arguments\n\norient=:Graph: choose between graph oriented :Graph, input oriented :Input, or output oriented model :Output.\nrts=:VRS: choose between constant returns to scale :CRS or variable returns to scale :VRS.\nrhoX: matrix of weights of inputs. Only if model=:Custom.\nrhoY: matrix of weights of outputs. Only if model=:Custom.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\ndisposX=:Strong: chooses strong disposability of inputs. For weak disposability choose :Weak.\ndisposY=:Strong: chooses strong disposability of outputs. For weak disposability choose :Weak.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"technical/radial/#Radial-Models","page":"Radial Models","title":"Radial Models","text":"","category":"section"},{"location":"technical/radial/#Radial-Input-Oriented-Model","page":"Radial Models","title":"Radial Input Oriented Model","text":"Based on the data  matrix (XY), we calculate the input oriented efficiency of each observation o by solving n times the following linear programming problem – known as the Charnes, Cooper, and Rhodes (1978), CCR, model:\n\nbeginaligned\n   undersettheta mathbflambda mathopmin quad quad quad  theta  \n   textsubject textto  \n   quad quad quad quad quad  Xmathbflambda  le theta mathbfx_o \n   quad quad quad quad quad  Ymathbflambda  ge mathbfy_o  \n   quad quad quad quad quad  mathbflambda ge mathbf0 \nendaligned\n\nThe measurement of technical efficiency assuming variable returns to scale, VRS, as introduced by Banker, Charnes and Cooper (1984) – known as the Banker, Charnes and Cooper, BCC, model – adds the following condition:\n\nsumnolimits_j=1^nlambda_j=1\n\nIn this example we compute the radial input oriented DEA model under constant returns to scale:\n\nusing DataEnvelopmentAnalysis\n\nX = [5 13; 16 12; 16 26; 17 15; 18 14; 23 6; 25 10; 27 22; 37 14; 42 25; 5 17];\n\nY = [12; 14; 25; 26; 8; 9; 27; 30; 31; 26; 12];\n\ndea(X, Y, orient = :Input, rts = :CRS)\n\nTo compute the variable returns to scale model, we simply set the rts parameter to :VRS:\n\ndea(X, Y, orient = :Input, rts = :VRS)\n\nEstimated efficiency scores are returned with the efficiency function:\n\ndeaiovrs = dea(X, Y, orient = :Input, rts = :VRS);\nnothing # hide\n\nefficiency(deaiovrs)\n\nThe optimal peers, λ, are returned with the peers function and are returned as a DEAPeers object:\n\npeers(deaiovrs)\n\nInput and output slacks are returned with the slacks function:\n\nslacks(deaiovrs, :X)\n\nslacks(deaiovrs, :Y)\n\nInput and output optimal targets are returned with the targets function:\n\ntargets(deaiovrs, :X)\n\ntargets(deaiovrs, :Y)","category":"section"},{"location":"technical/radial/#Radial-Output-Oriented-Model","page":"Radial Models","title":"Radial Output Oriented Model","text":"It is possible to calculate the output oriented technical efficiency of each observation by solving the following linear program:\n\nbeginaligned\n  undersetphi mathbflambda mathopmax quad quad quad quad phi  \n  textsubject textto \n  quad quad quad quad quad  Xlambdale mathbfx_o \n  quad quad quad quad quad  Ymathbflambda  ge phi mathbfy_o \n  quad quad quad quad quad  mathbflambda ge mathbf0   quad \nendaligned\n\nwith the following condition when assuming variable returns to scale:\n\nsumnolimits_j=1^nlambda_j=1\n\nIn this example we compute the radial output oriented DEA model under variable returns to scale:\n\ndea(X, Y, orient = :Output, rts = :VRS)","category":"section"},{"location":"technical/radial/#Radial-Model-in-Multiplier-Form","page":"Radial Models","title":"Radial Model in Multiplier Form","text":"The dual to the input oriented and output oriented radial DEA models in envelopment form presented above is the multiplier form.\n\nThis example computes the radial input-oriented DEA model in multiplier form under variable returns to scale:\n\ndeaiovrsm = deam(X, Y, rts = :VRS)\n\nInput and output virtual multipliers (shadow prices) are returned with the multipliers function:\n\nmultipliers(deaiovrsm, :X)\n\nmultipliers(deaiovrsm, :Y)\n\nThe value measuring the returns to scale is returned with the rts function:\n\nrts(deaiovrsm)","category":"section"},{"location":"technical/radial/#dea-Function-Documentation","page":"Radial Models","title":"dea Function Documentation","text":"","category":"section"},{"location":"technical/radial/#DataEnvelopmentAnalysis.dea","page":"Radial Models","title":"DataEnvelopmentAnalysis.dea","text":"dea(X, Y)\n\nCompute the radial model using data envelopment analysis for inputs X and outputs Y.\n\nOptional Arguments\n\norient=:Input: chooses the radially oriented input mode. For the radially oriented output model choose :Output.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nslack=true: computes input and output slacks.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\ndisposX=:Strong: chooses strong disposability of inputs. For weak disposability choose :Weak.\ndisposY=:Strong: chooses strong disposability of outputs. For weak disposability choose :Weak.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"technical/radial/#DataEnvelopmentAnalysis.deam","page":"Radial Models","title":"DataEnvelopmentAnalysis.deam","text":"deam(X, Y)\n\nCompute the radial multiplier model using data envelopment analysis for inputs X and outputs Y.\n\nOptional Arguments\n\norient=:Input: chooses the radially oriented input mode. For the radially oriented output model choose :Output.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"technical/radialbigdata/#Radial-Big-Data-Models","page":"Radial Big Data Models","title":"Radial Big Data Models","text":"When the number of decision-making units is large, traditional DEA models are slow to solve. Khezrimotlagh, Zhu, Cook, and Toloo (2019), propose a framework that reduces the computational time by finding the set of best practices DMUs from a subsample and evaluating the rest of the decision-making units with respect to the best performers.\n\nThe proposed framework includes five steps:\n\nSelect a subsample of DMU.\nFind the best practices in the subsample.\nFind the exterior DMUs with respect to the hull of the best practices.\nIdentify the set of all efficient DMUs.\nCalculate performance scores as in the traditional DEA model.\n\nThis example computes the Big Data radial input-oriented DEA model under variable returns to scale, using random data drawn from a uniform distribution. 500 DMUs with six inputs and four outputs in the interval (10, 20) are generated:\n\n# Generate random data\nusing DataEnvelopmentAnalysis\nusing Distributions\nusing Random\nusing StableRNGs\n\nrng = StableRNG(1234567)\nX = rand(Uniform(10, 20), 500, 6);\nY = rand(Uniform(10, 20), 500, 4);\n\n# Calculate the Big Data DEA Model\ndeabig = deabigdata(X, Y)\n\n# Get efficiency scores\nefficiency(deabig)","category":"section"},{"location":"technical/radialbigdata/#deabigdata-Function-Documentation","page":"Radial Big Data Models","title":"deabigdata Function Documentation","text":"","category":"section"},{"location":"technical/radialbigdata/#DataEnvelopmentAnalysis.deabigdata","page":"Radial Big Data Models","title":"DataEnvelopmentAnalysis.deabigdata","text":"deabigdata(X, Y)\n\nCompute the big data radial model using data envelopment analysis for inputs X and outputs Y.\n\nOptional Arguments\n\norient=:Input: chooses the radially oriented input mode. For the radially oriented output model choose :Output.\nrts=:CRS: chooses constant returns to scale. For variable returns to scale choose :VRS.\natol=1e-6: tolerance for DMU to be considered efficient.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"economic/cost/#Cost-Models","page":"Cost Models","title":"Cost Models","text":"","category":"section"},{"location":"economic/cost/#Cost-Efficiency-Model-with-Radial-Technical-Efficiency","page":"Cost Models","title":"Cost Efficiency Model with Radial Technical Efficiency","text":"Let us denote by Cleft(mathbfymathbfwright) the minimum cost of producing the output level mathbfy given the input price vector mathbfw: Cleft(mathbfymathbfwright)=min left sumlimits_i=1^mw_ix_i  mathbfx geqslant Xmathbflambda mathbfy_o leqslant Ymathbflambda mathbflambda  geqslant mathbf0 right, which considers the input possibility set capable of producing mathbfy_o. For the observed outputs levels we can calculate minimum cost and the associated optimal quantities of inputs mathbfx^* consistent with the production technology by solving the following program:\n\nbeginaligned\n  undersetmathbfx mathbflambda mathopmin quad quad quad  Cleft(mathbfy_mathbfwright)=mathbfwx^*   \n  textsubject textto  \n  quad quad quad quad quad  mathbfxge Xmathbflambda   \n  quad quad quad quad quad  Ymathbflambda  ge mathbfy_o   \n  quad quad quad quad quad  mathbflambda ge mathbf0 \nendaligned\n\nThe measurement of cost efficiency assuming variable returns to scale, VRS, adds the following condition:\n\nsumnolimits_j=1^nlambda_j=1\n\nCost efficiency defines as the ratio of minimum cost to observed cost: CE=Cleft(mathbfymathbfwright)mathbfwx_o. Thanks to duality results presented by Shephard (1953) , and following Farrell (1957), cost efficiency can be decomposed into the radially input oriented technical efficiency measure and the residual difference corresponding to allocative cost efficiency. Allocative  efficiency defines as the ratio between minimum cost to production cost at the technically efficient projection of the unit under evaluation.\n\nIn this example we compute the cost efficiency measure under variable returns to scale:\n\nusing DataEnvelopmentAnalysis\n\nX = [5 3; 2 4; 4 2; 4 8; 7 9.0];\n\nY = [7 4; 10 8; 8 10; 5 4; 3 6.0];\n\nW = [2 1; 2 1; 2 1; 2 1; 2 1.0];\n\ndeacost(X, Y, W)","category":"section"},{"location":"economic/cost/#deacost-Function-Documentation","page":"Cost Models","title":"deacost Function Documentation","text":"","category":"section"},{"location":"economic/cost/#DataEnvelopmentAnalysis.deacost","page":"Cost Models","title":"DataEnvelopmentAnalysis.deacost","text":"deacost(X, Y, W)\n\nCompute cost efficiency using data envelopment analysis for inputs X, outputs Y and price of inputs W.\n\nOptional Arguments\n\nrts=:VRS: chooses variable returns to scale. For constant returns to scale choose :CRS.\ndispos=:Strong: chooses strong disposability of outputs. For weak disposability choose :Weak.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"Aparicio, J., Pastor, J. T., and Ray, S. C. (2013). \"An overall measure of technical inefficiency at the firm and at the industry level: the ‘lost profit on outlay’.\" European Journal of Operational Research, 226(1), 154-162.\nAparicio J., Pastor J. T., Zofío J. L. (2013). \"**On the Inconsistency of the Malmquist-Luenberger Index.\" European Journal of Operational Research, 229(3), 738–742. \nBanker, R., Charnes, A., and Cooper, W.W. (1984). \"Some Models for Estimating Technical and Scale Inefficiencies in Data Envelopment Analysis.\" Management Science, 30(9), 1078–1092.\nBriec, W. (1998). \"Hölder distance function and measurement of technical efficiency.\" Journal of Productivity Analysis, 11: 111–131.\nCaves D.W., Christensen L.R., Diewert, W.E. (1982). \"The Economic Theory of Index Numbers and the Measurement of Input, Output, and Productivity.\" Econometrica, 50(6), 1393–1414.\nChambers, R.G., Chung, Y., and Färe R. (1996). \"Benefit and Distance Functions.\" Journal of Economic Theory, 70(2), 407 – 419.\nChambers, R.G., Chung, Y., and Färe R. (1998). \"Profit, Directional Distance Functions, and Nerlovian Efficiency.” Journal of Optimization Theory and Applications, 98(2), 351-364.\nCharnes, A., Cooper, W.W., and Rhodes, E. (1978). \"Measuring the efficiency of decision making units.\" European Journal of Operational Research, 2(6), 429–444.\nCharnes, A., Cooper, W.W., Rousseau, J. , and Semple, J. (1987). \"Data Envelopment Analyses and Axiomatic Notions of Efficiency and Reference Sets.\" Research Report, Center for Cybernetic Studies, The University of Texas at Austin.\nChavas J., and Cox, T. (1999). \"A Generalized Distance Function and the Analysis of Production Efficiency.\" Southern Economic Journal, 66(2), 294-318.\nCooper, W.W., Park, K.S. and Pastor, J.T. (1999). \"RAM: A Range Adjusted Measure of Inefficiency for Use with Additive Models, and Relations to Other Models and Measures in DEA\" Journal of Productivity Analysis 11(1), 5-42. \nCooper, W.W., and Pastor, J.T. (1995). \"Global Efficiency Measurement in DEA.” Working Paper, Depto Est e Inv. Oper. Universidad Alicante, Alicante, Spain.\nCooper, W.W., Pastor, J.T., Borras, F., Aparicio, J. and Pastor, D. (2011). \"BAM: a bounded adjusted measure of efficiency for use with bounded additive models.\" Journal of Productivity Analysis, 35(2), 85-94.\nChung, Y. H., Färe, R., Grosskopf, S. (1997). \"Productivity and Undesirable Outputs: A Directional Distance Function Approach.\" Journal of Environmental Management, 51(3), 229–240.\nFare, R., and Lovell, C. K. (1978). \"Measuring the technical efficiency of production.\" Journal of Economic theory, 19(1), 150-162.\nFare, R., Grosskopf, S., and Lovell,C.A.K., (1985). The Measurement of Efficiency of Production. Kluwer Nijhof Publishing.\nFare, R., Grosskopf, S., Norris, M. and Zhang, Z. (1994). \"Productivity Growth, Technical Progress, and Efficiency Change in Industrialized Countries.\" American Economic Review, 84(1), 66–83.\nFarrell, M. J. (1957). \"The Measurement of Productive Efficiency of Production.\" Journal of the Royal Statistical Society, Series A, 120(III), 253-281.\nKhezrimotlagh, D., Zhu, J., Cook, W.D., and Toloo, M. (2019). \"Data envelopment analysis and big data.\" European Journal of Operational Research, 274(3): 1047-1054\nLovell, C. A. K., and Pastor, J. T. (1995). \"Units Invariant and Translation Invariant DEA Models.\" Operations Research Letters, 18, 147–151.\nPastor, J.T., Aparicio, J., Alcaraz, J., Vidal, F. and Pastor, D. (2016). “The Reverse Directional Distance Function” in Advances in Efficiency and Productivity, edited by J. Aparicio, C.A.K. Lovell and J.T. Pastor, Springer, Cham. \nPastor, J. T., Ruiz, J. L., and Sirvent, I. (1999). \"An enhanced DEA Russell graph efficiency measure.\" European Journal of Operational Research, 115(3), 596-607.\nPastor, J.T., Lovell, C.A.K., and Aparicio, J. (2012). \"Families of linear efficiency programs based on Debreu’s loss function.\" Journal of Productivity Analysis 38(2), 109-120.\nSimar, L., and Wilson, P. (1988). \"Sensitivity Analysis of Efficiency Scores: How to Bootstrap in Nonparametric Frontier Models,\" Management Science, 44(1), 49-61.\nSimar, L., and Wilson, P. (2002). \"NNon-parametric tests of returns to scale,\" European Journal of Operational Research 139, 115–132.\nShephard, R.W. (1953). Cost and production functions. Princeton University Press, Princeton, New Jersey.\nTone, K. (2001). \"A slacks-based measure of efficiency in data envelopment analysis.\" European Journal of Operational Research, 130(3), 498-509.\nZofío, J.L. and Prieto, A.M. (2006). \"Return to Dollar, Generalized Distance Function and the Fisher Productivity Index\" Spanish Economic Review, 8(2), 113-138.","category":"section"},{"location":"#DataEnvelopmentAnalysis.jl","page":"Home","title":"DataEnvelopmentAnalysis.jl","text":"DataEnvelopmentAnalysis.jl is a Julia package that provides functions for efficiency and productivity measurement using Data Envelopment Analysis (DEA). Particularly, it implements a variety of technical efficiency models, economic efficiency models and productivity change models.\n\nThe package is being developed for Julia 1.6 and above on Linux, macOS, and Windows.\n\nThe packes uses internally the JuMP modelling language for mathematicall optimization with solvers GLPK and Ipopt.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The package can be installed with the Julia package manager:\n\njulia> using Pkg; Pkg.add(\"DataEnvelopmentAnalysis\")","category":"section"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"For a tutorial on how to use the package, check the documentation on the Radial Input Oriented Model.","category":"section"},{"location":"#Available-models","page":"Home","title":"Available models","text":"Technical efficiency DEA models:\n\nPages = [\"technical/radial.md\", \"technical/radialbigdata.md\", \"technical/directional.md\", \"technical/additive.md\", \"technical/generalizeddf.md\", \"technical/russell.md\", \"technical/enhancedrussell.md\", \"technical/modifiedddf.md\", \"technical/holder.md\", \"technical/reverseddf.md\", \"technical/environmental.md\"]\nDepth = 2\n\nEconomic efficiency DEA models:\n\nPages = [\"economic/cost.md\", \"economic/revenue.md\", \"economic/profit.md\", \"economic/profitability.md\"]\nDepth = 1\n\nProductivity change models:\n\nPages = [\"productivity/malmquist.md\", \"productivity/malmquistluenberger.md\"]\nDepth = 1\n\nStatistical Analysis:\n\nPages = [\"statistical/radialboot.md\", \"statistical/rtstest.md\"]\nDepth = 1","category":"section"},{"location":"#Extensions","page":"Home","title":"Extensions","text":"The BenchmarkingEconomicEfficiency.jl package provides an extensive set of functions for economic efficiency measurement using Data Envelopment Analysis (DEA).","category":"section"},{"location":"#Authors","page":"Home","title":"Authors","text":"DataEnvelopmentAnalysis.jl is being developed by Javier Barbero and José Luís Zofío.","category":"section"},{"location":"technical/reverseddf/#Reverse-Directional-Distance-Function","page":"Reverse Directional Distance Function","title":"Reverse Directional Distance Function","text":"In this example, we compute the Reverse Directional Distance Function (Pastor et al., 2016) DEA model for the Enhanced Russell Graph associated efficiency measure under variable returns to scale:\n\nusing DataEnvelopmentAnalysis\n\nX = [2; 4; 8; 12; 6; 14; 14; 9.412];\n\nY = [1; 5; 8; 9; 3; 7; 9; 2.353];\n\nrddferg = dearddf(X, Y, :ERG, rts = :VRS)\n\nEstimated efficiency scores are returned with the efficiency function:\n\nefficiency(rddferg)","category":"section"},{"location":"technical/reverseddf/#dearddf-Function-Documentation","page":"Reverse Directional Distance Function","title":"dearddf Function Documentation","text":"","category":"section"},{"location":"technical/reverseddf/#DataEnvelopmentAnalysis.dearddf","page":"Reverse Directional Distance Function","title":"DataEnvelopmentAnalysis.dearddf","text":"dearddf(X, Y, measure)\n\nCompute data envelopment analysis reverse directional distance function (RDDF) model for inputs X, outputs Y, and efficiency measure  measure.\n\nMeasure specification:\n\n:ERG: Enhanced Russell Graph (or Slack Based Measure (SBM)).\n:MDDF: Modified Directional Distance Function.\n\nDirection specification:\n\nFor the Modified Directional Distance Function, the directions Gx and Gy can be one of the following symbols.\n\n:Ones: use ones.\n:Observed: use observed values.\n:Mean: use column means.\n\nOptional Arguments\n\norient=:Graph: choose between graph oriented :Graph, input oriented :Input, or output oriented model :Output.\nrts=:CRS: choose between constant returns to scale :CRS or variable returns to scale :VRS.\natol=1e-6: tolerance for DMU to be considered efficient.\nXref=X: Identifies the reference set of inputs against which the units are evaluated.\nYref=Y: Identifies the reference set of outputs against which the units are evaluated.\nnames: a vector of strings with the names of the decision making units.\n\n\n\n\n\n","category":"function"}]
}
